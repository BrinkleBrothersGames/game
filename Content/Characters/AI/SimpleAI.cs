using Game.Content.World;
using SurvivalGame.Content.Items;
using SurvivalGame.Content.World;
using SurvivalGame.Content.World.TerrainTypes;
using SurvivalGame.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SurvivalGame.Content.Characters.AI
{
    // TODO - For more advanced AI capable of better route-finding, should store a list of squares the creature has previously visited. This would be its 'memory', and could help avoid repeated movements. Length of memory should be based on creature's intelligence.
    // TODO - Useful methods would include: coord creator in MapUtils; perceivableTiles -> map.layout translator; IsValidMove(int[], map),  two functions (?) determine whether a square is in the bounds of the map and another one determines whether a square blockMovement
    // TODO - PERCEIVABLE TILE COORDS TO MAP COORD TRANSLATOR! DO THIS SOON, AND REAP THE REWARDS!
    // The Simple AI class represents a dumb animal. It will seek safety, then to satisfy its needs. No complex or interesting behaviour.
    public class SimpleAI
    {
        // TODO - these contants should be replaced with values derived from stats, when stats are implemented.
        int creatureIntelligence = 20; // Used in pathfinding
        int curiosity = 2; // Used in determining liklihood of movement when idle (how likely the monster is to wander around when 'bored'). Should be between 0/10. May need to think more carefully about this in future.

        int[] targetCoords; // The coords of the AI's current target. Can be an enemy to flee from/attack or food/drink, etc.
        List<int[]> adjacentTiles;
        List<int[]> previouslyVisitedTiles = new List<int[]>(); // This should be much more powerful: maybe a weighting system that adds tiles the creature has visited often to its permenant memory?
        Tile[,] perceivableTiles; // TODO - consider implications of replacing with dictionary
        Dictionary<ConsumableItem, int[]> perceivableConsumableItems = new Dictionary<ConsumableItem, int[]>();
        Creature creature;
        Map map;
        Random rnd = new Random(Map.SEED);

        public SimpleAI(Creature creature)
        {
            this.creature = creature;
        }

        public void Update(Creature creature)
        {
            this.creature = creature;
        }

        public void Update(Map map)
        {
            this.map = map;
        }

        // Core logic for choosing an action
        public void ActionSelection()
        {
            // We need to know what the creature is aware of. Its actions will depend on this.
            // TODO - remove magic int here. Should be determined by creature's perception stat.
            perceivableTiles = GetTilesInPerceptionRange(5);
            adjacentTiles = GetAdjacentTiles();
            perceivableConsumableItems = GetPerceivableConsumableItems();

            // First it prioritises its safety. If it's in serious danger, or is hurt and is in less danger, it should flee. If it can't flee, it should fight.
            if(IsInDanger() || (IsInjured() && IsThreatened()))
            {
                if (CanFlee())
                {
                    Flee();
                }
                else
                {
                    Fight();
                }
            }  
            else if (IsThirsty()) // If thirsty, seek a drink
            {
                SeekDrink();
            }
            else if (IsHungry()) // If hungry, seek food
            {
                SeekFood();
            }
            else if (IsTired() && !IsThreatened()) // If tired and safe, sleep
            {
                Sleep();
            }
            else
            {
                Idle();
            }
        }

        // The following methods are use by the intelligence to determine actions. They represent its knowledge of the world.

        // Returns true if a 'threat' is within a creature's comfort range.
        public bool IsInDanger()
        {
            // TODO - replace magic string with something determined from a stat the creature has. Replace magic 'threat' with some kind of threat list generated by creature
            int comfortRange = 2;
            Terrain threat = new Terrain("player");

            for (int y = (comfortRange * 2); y > 0; y--)
            {
                for (int x = 0; x <= (comfortRange * 2); x++)
                {
                    if (perceivableTiles[(perceivableTiles.GetLength(0) / 2) + x - comfortRange, (perceivableTiles.GetLength(1) / 2) + y - comfortRange]!=null && perceivableTiles[(perceivableTiles.GetLength(0) / 2) + x - comfortRange, (perceivableTiles.GetLength(1) / 2) + y - comfortRange].contentsTerrain.Contains(threat))
                    {
                        // Converts x and y to values in the creature's perception range, then sets those as its 'targetCoords'
                        targetCoords = new int[] { (perceivableTiles.GetLength(0) / 2) + x - comfortRange, (perceivableTiles.GetLength(1) / 2) + y - comfortRange };
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Returns true if a 'threat' is within the creature's perception range.
        public bool IsThreatened()
        {
            Terrain threat = new Terrain("player");
            int perceptionRange = perceivableTiles.GetLength(0)/2;

            for (int y = (perceptionRange * 2); y > 0; y--)
            {
                for (int x = 0; x <= (perceptionRange * 2); x++)
                {
                    if ((perceivableTiles[x, y] != null) && perceivableTiles[x, y].contentsTerrain.Contains(threat))
                    {
                        targetCoords = new int[] { x, y};
                        return true;
                    }
                }
            }
            return false;
        }

        // Checks if a movement to an adjacent square moves creature away from a threat. Returns true if a square exists that doesn't block movement and doesn't contain the threat
        public bool CanFlee()
        {
            Terrain threat = new Terrain("player");
            int[] creatureCoords = new int[] { (perceivableTiles.GetLength(0) / 2), (perceivableTiles.GetLength(0) / 2) };
            int currentThreatDistance = MapUtils.GetAbsoluteDistanceBetweenTwoPoints(creatureCoords, targetCoords);
            int newThreatDistance = currentThreatDistance;

            foreach(int[] tileCoords in adjacentTiles)
            {
                newThreatDistance = MapUtils.GetAbsoluteDistanceBetweenTwoPoints(tileCoords, targetCoords);
                
                if((perceivableTiles[tileCoords[0], tileCoords[1]]!=null) && !(perceivableTiles[tileCoords[0], tileCoords[1]].blocksMovement) && (newThreatDistance > currentThreatDistance))
                {
                    return true;
                }
            }
            return false;
        }

        public bool CanPerceiveConsumable(string need)
        {
            foreach(KeyValuePair<ConsumableItem, int[]> dictPair in perceivableConsumableItems)
            {
                if(dictPair.Key.GetType() == typeof(ConsumableItem))
                {

                }
            }

            return false;
        }

        public bool IsInjured()
        {
            // TODO - REMOVE MAGIC STRINGS! COME ON!
            if(creature.needs.health < 4)
            {
                return true;
            }
            return false;
        }

        public bool IsThirsty()
        {
            // TODO - MAGIC STRINGS! BEGONE!
            if(creature.needs.thirstLevel < 5)
            {
                return true;
            }
            return false;
        }

        public bool IsHungry()
        {
            // TODO - Clear magic string
            if(creature.needs.hungerLevel < 5)
            {
                return true;
            }
            return false;
        }

        public bool IsTired()
        {
            // TODO - Get rid of magic string
            if(creature.needs.tirednessLevel < 4)
            {
                return true;
            }
            return false;
        }

        // The following methods are used to gather information about the world
        // TODO - perception range shouldn't passed in, it should be known/calculated from the creature itself
        public Tile[,] GetTilesInPerceptionRange(int perceptionRange)
        {
            // TODO - only done temporarily for rats - remove this when we have stats in place
            perceptionRange = 5;

            Tile[,] perceivableTiles = new Tile[(perceptionRange * 2) + 1, (perceptionRange * 2) + 1];

            // Loop over tiles within perception range and add them to a smaller grid, for use in decision making
            for (int y = (perceptionRange * 2); y > 0; y--)
            {
                for (int x = 0; x <= (perceptionRange * 2); x++)
                {
                    if (!(creature.position[0] + x - perceptionRange < 0 || creature.position[0] + x - perceptionRange >= map.layout.GetLength(0) || (creature.position[1] + y - perceptionRange) < 0 || (creature.position[1] + y - perceptionRange) >= map.layout.GetLength(1)))
                    {
                        perceivableTiles[x, y] = map.layout[(creature.position[0] + x - perceptionRange), (creature.position[1] + y - perceptionRange)];
                    }
                }
            }

            return perceivableTiles;
        }

        // TODO - decide whether this should be put together with 'getTilesInPerceptionRange'. Is it better to do this every time, or just when it's needed?
        public Dictionary<ConsumableItem, int[]> GetPerceivableConsumableItems()
        {
            Dictionary<ConsumableItem, int[]> perceivableItems = new Dictionary<ConsumableItem, int[]>();

            // Foreach nonempty tile the creature can perceive...
            for (int y = perceivableTiles.GetLength(1) - 1 ; y > 0; y--)
            {
                for (int x = 0; x <= perceivableTiles.GetLength(0) - 1; x++)
                {
                    if (perceivableTiles[x, y] != null)
                    {
                        foreach (KeyValuePair<Item, int> itemNumberPair in perceivableTiles[x, y].contentsItems.inventory)
                        {
                            // ... add the tile's contents and its location to our dictionary.
                            if (itemNumberPair.Key.GetType() == typeof(ConsumableItem))
                            {
                                perceivableItems.Add(itemNumberPair.Key as ConsumableItem, new int[] { x, y });
                            }
                        }
                    }
                }
            }
            
            return perceivableItems;
        }

        public List<int[]> GetAdjacentTiles()
        {
            int[] upTile = new int[] { (perceivableTiles.GetLength(0)) / 2, ((perceivableTiles.GetLength(1)) / 2) + 1 };
            int[] downTile = new int[] { (perceivableTiles.GetLength(0) / 2), ((perceivableTiles.GetLength(1)) / 2) - 1 };
            int[] leftTile = new int[] { ((perceivableTiles.GetLength(0)) / 2) - 1, ((perceivableTiles.GetLength(1)) / 2) };
            int[] rightTile = new int[] { ((perceivableTiles.GetLength(0) / 2)) + 1, ((perceivableTiles.GetLength(1)) / 2) };
                
            List<int[]> adjacentTiles = new List<int[]> { upTile, downTile, leftTile, rightTile};

            return adjacentTiles;
        }

        public void UpdatePreviouslyVisitedTiles(int[] newlyVisited)
        {
            previouslyVisitedTiles.Add(newlyVisited);

            // If more tiles are in the list than the creature can remember, forget the oldest (ie first) tile
            if(previouslyVisitedTiles.Count > creatureIntelligence)
            {
                previouslyVisitedTiles.RemoveAt(0);
            }
        }
        
        // The following methods are the actions the AI will undertake.
        public void Flee()
        {
            Terrain threat = new Terrain("player");
            int[] creatureCoords = new int[] { (perceivableTiles.GetLength(0) / 2), (perceivableTiles.GetLength(1) / 2) };
            int currentThreatDistance = MapUtils.GetAbsoluteDistanceBetweenTwoPoints(creatureCoords, targetCoords);
            int newThreatDistance = currentThreatDistance;
            
            // TODO - This randomises the order of a list to ensure more random movement of creatures. This should be in a utils class
            int n = adjacentTiles.Count;
            while (n > 1)
            {
                n--;
                int k = rnd.Next(n + 1);
                int[] value = adjacentTiles[k];
                adjacentTiles[k] = adjacentTiles[n];
                adjacentTiles[n] = value;
            }

                foreach (int[] tileCoords in adjacentTiles)
            {
                newThreatDistance = MapUtils.GetAbsoluteDistanceBetweenTwoPoints(tileCoords, targetCoords);

                if ((perceivableTiles[tileCoords[0], tileCoords[1]]!=null) && !(perceivableTiles[tileCoords[0], tileCoords[1]].blocksMovement) && (newThreatDistance > currentThreatDistance))
                {
                    int[] newPosition = new int[] { creature.position[0] + (tileCoords[0] - ((perceivableTiles.GetLength(0)) / 2)), creature.position[1] + (tileCoords[1] - ((perceivableTiles.GetLength(1)) / 2)) };
                    creature.UpdatePosition(map, newPosition);
                    return;
                }
            }
        }

        public void Fight()
        {
            Console.WriteLine("Ai chooses Fight action");
        }

        public void SeekDrink()
        {

            Console.WriteLine("Ai chooses SeekDrink action");
        }

        public void SeekFood()
        {
            Console.WriteLine("Ai chooses SeekFood action");
        }

        public void Sleep()
        {
            Console.WriteLine("Ai chooses Sleep action");
        }

        public void Idle()
        {
            // TODO - for now this is random, but could be deterministic? Consider this
            int idleAction = rnd.Next(1, 11);
            Console.WriteLine("idleAction = " + idleAction.ToString());

            // If random number greater than creature's curiosity, they don't wander. Do nothing.
            // TODO - Maybe this shouldn't be curiosity... would something like 'activeness' be more appropes?
            if (idleAction > curiosity)
            {
                // Do nothing
                return;
            }
            else
            {
                // Creature wanders around.
                Wander();
            }
        }

        public void Wander()
        {
            Dictionary<int[], int> weightDictionary = new Dictionary<int[], int>();

            // Weights how much the creature should prefer each adjacent tile
            foreach (int[] tileCoords in adjacentTiles)
            {
                int weight = 0;

                if ((perceivableTiles[tileCoords[0], tileCoords[1]] != null) && (!perceivableTiles[tileCoords[0], tileCoords[1]].blocksMovement))
                {
                    // If current tile has been visited recently, weigh more strongly for less curious creatures.
                    if (previouslyVisitedTiles.Contains(MapUtils.ConvertPerceivableMapCoordsToMapCoords(tileCoords, perceivableTiles, map, creature.position)))
                    {
                        // TODO - the 10 should be set in a global variable as "MAX_CURIOSITY" or something. May want to do this differently.
                        weight += 2*(10 - curiosity);
                    }
                    else // If tile not visited before, weight more strongly if creature is very curious
                    {
                        weight += curiosity;
                    }

                    weightDictionary.Add(tileCoords, weight);
                }
            }

            var list = weightDictionary.Keys.ToList();
            // Get the total weighting given to all adjacent squares, then generate a number between 1 and this.
            int totalWeight = list.Sum(x => weightDictionary[x]);
            int directionChosen = rnd.Next(1, totalWeight + 1);

            foreach(int[] tile in list)
            {
                // Take the weight of the current square from our generated number
                directionChosen -= weightDictionary[tile];
                    
                if (directionChosen <= 0) // Then this is the direction we move in. Do so and return.
                {
                    int[] newCoords = MapUtils.ConvertPerceivableMapCoordsToMapCoords(tile, perceivableTiles, map, creature.position);

                    creature.UpdatePosition(map, newCoords);
                    UpdatePreviouslyVisitedTiles(newCoords);
                    return;
                }
            }
            
        }
    }
}
